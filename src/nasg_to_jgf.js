#! /usr/bin/env node

import ArraySchema from 'normalizr/lib/IterableSchema'
import EntitySchema from 'normalizr/lib/EntitySchema'
import UnionSchema from 'normalizr/lib/UnionSchema'
import {type} from 'ramda'
import read from 'read-file-stdin'

import * as schemas from './schemas'

const attributesByEntityType = {
  ArithmeticOperation: {shape: 'circle'},
  Constant: {shape: 'oval'},
  Parameter: {shape: 'box', style: 'filled'},
  ValueForEntity: {shape: 'trapezium', penwidth: 3},
  ValueForRole: {shape: 'trapezium'},
  Variable: {shape: 'oval', style: 'filled'},
  VariableReference: {shape: 'oval', style: 'dotted'}
}

function checkTarget (target) {
  if (type(target) !== 'Number') {
    throw new TypeError(`ASG is not normalized correctly, unexpected reference: ${target}`)
  }
}

function renderLabel (entity) {
  const functionByEntityType = {
    ArithmeticOperation: entity => entity.operator,
    Constant: entity => `${entity.type} ${entity.value}`,
    Parameter: entity => entity.path.join('.'),
    PeriodOperation: entity => `${entity.type}\n${entity.operator}`,
    ValueForEntity: entity => `${entity.type}\n${entity.operator}`,
    ValueForRole: entity => `${entity.type}\n${entity.role}`,
    Variable: entity => `${entity.type}\n${entity.name}@${entity.entity}`,
    VariableReference: entity => `${entity.type}\n${entity.name}`
  }
  return functionByEntityType.hasOwnProperty(entity.type)
      ? functionByEntityType[entity.type](entity)
      : entity.type
}

function referenceKeys (schema, entity) {
  return Object.keys(schema).filter(key => {
    const value = schema[key]
    return entity.hasOwnProperty(key) && (
      value instanceof ArraySchema ||
      value instanceof EntitySchema ||
      value instanceof UnionSchema
    )
  })
}

function main (data) {
  if (data.result === null || data.entities === null) {
    throw new TypeError('Provide a normalized ASG')
  }
  // Build nodes and edges
  const edgesAttributes = {
    labeldistance: 0
  }
  const nodes = []
  const edges = []
  const {entities} = data
  for (let entityType in entities) {
    const entityById = entities[entityType]
    for (let id in entityById) {
      const entity = entityById[id]
      id = entity.id // Overwrite with integer value (keys are strings).
      const attributes = attributesByEntityType[entity.type] || {shape: 'box'}
      const label = renderLabel(entity)
      nodes.push({id, label, ...attributes})
      const schema = schemas[entityType]
      for (let referenceKey of referenceKeys(schema, entity)) {
        const referencedSchema = schema[referenceKey]
        if (referencedSchema instanceof EntitySchema) {
          const target = entity[referenceKey]
          checkTarget(target)
          edges.push({
            source: id,
            target,
            directed: true,
            label: referenceKey,
            ...edgesAttributes
          })
        } else if (referencedSchema instanceof ArraySchema) {
          const targetReferences = entity[referenceKey]
          // ArraySchema can be generated by arrayOf or valuesOf.
          if (type(targetReferences) === 'Array') {
            targetReferences.forEach((targetReference, index) => {
              let target
              if (type(targetReference) === 'Object') {
                target = targetReference.id
              } else if (type(targetReference) === 'Number') {
                target = targetReference
              } else {
                throw new TypeError(`Unexpected type for targetReference: ${targetReference}`)
              }
              checkTarget(target)
              edges.push({
                source: id,
                target,
                directed: true,
                ...edgesAttributes
              })
            })
          } else if (type(targetReferences) === 'Object') {
            // TODO Do not hardcode pyvariableName.
            Object.keys(targetReferences).forEach(pyvariableName => {
              const target = targetReferences[pyvariableName].id
              checkTarget(target)
              const id = `${target}.${pyvariableName}`
              nodes.push({
                id,
                label: pyvariableName,
                fontcolor: 'grey',
                color: 'grey',
                shape: 'cds'
              })
              edges.push({
                source: id,
                target,
                directed: true,
                color: 'grey'
              })
            })
          } else {
            throw new TypeError(`Unexpected type for targetReferences: ${targetReferences}`)
          }
        } else if (referencedSchema instanceof UnionSchema) {
          const target = entity[referenceKey].id
          checkTarget(target)
          edges.push({
            source: id,
            target,
            directed: true,
            label: referenceKey,
            ...edgesAttributes
          })
        } else {
          throw new TypeError(`Unexpected type for referencedSchema: ${referencedSchema}`)
        }
      }
    }
  }
  const result = {
    graph: {
      directed: true,
      nodes,
      edges
    }
  }
  console.log(JSON.stringify(result, null, 2))
}

read(process.argv[2], (err, buffer) => {
  if (err) throw err
  const data = JSON.parse(buffer)
  main(data)
})
